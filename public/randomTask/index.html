<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Google Fonts -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Nunito:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap">
  <!-- Typicons -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/typicons/2.0.9/typicons.css"/>
  <!-- Flavicon -->
  <link rel="apple-touch-icon" sizes="180x180" href="../apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
  <title>Random Task</title>
</head>

<body>
<style>
  *{
    font-family: 'Nunito', sans-serif;
    color: darkslategrey;
    box-sizing: border-box;
  }
  button {
    border-top: 2px solid darkslategrey;
    border-left: 2px solid darkslategrey;
    border-right: 4px solid darkslategrey;
    border-bottom: 4px solid darkslategrey;
    border-radius: 5px;
    padding: 5px 10px;
    width: fit-content;
    color: darkslategrey;
    text-align: center;
    font-size: 1em;
    font-weight: 600;
    background-color: lightgrey;
  }
  button span:nth-of-type(1){
    padding-right: 5px;
  }
  button span:nth-of-type(2){
    padding-left: 5px;
  }
  input[type="text"], textarea{
    border-top: 2px solid darkslategrey;
    border-left: 2px solid darkslategrey;
    border-right: 4px solid darkslategrey;
    border-bottom: 4px solid darkslategrey;
    border-radius: 5px;
    padding: 5px 10px;
    width: fit-content;
    color: darkslategrey;
    font-size: 1em;
    font-weight: 600;
  }
  input[type="radio"]{
    display: none;
  }
  .Screen{
    display: flex;
    background-color: white;
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    z-index: 2000;
  }
  .DivScreen{
    width: 62%;
    padding: 15px;
    margin: auto;
    border-style: solid;
    border-width: 2px 3px 3px 2px;
    border-radius: 5px;
    z-index: 2200;
    text-align: center;
    position: relative;
  }
  #exitX{
    position: absolute;
    top: 5px;
    right: 7px;
    font-size: 25px;
    line-height: 25px;
    font-weight: 700;
  }
  .ScreenBtn1{
    display: block;
    margin: 10px auto;
  }
  .ScreenBtn2{
    border-top: 1px solid darkslategrey;
    border-left: 1px solid darkslategrey;
    border-right: 2px solid darkslategrey;
    border-bottom: 2px solid darkslategrey;
    border-radius: 3px;
    padding: 3px 7px;
    font-size: .7em;
    font-weight: 500;
    background-color: rgba(211, 211, 211, .5);
  }
  #cloudIt{
    float: right;
    margin-top: 15px;
    font-size: 25px;
    line-height: 1em;
    padding: 2px 0 2px 5px;
    background-color: rgba(237, 20, 61, 0);
  }
  #listSection{
    position: relative;
  }
  #clickScreen{
    position: fixed;
    width: 100vw;
    height: 100vh;
    top: 0;
    left: 0;
    z-index: 500;
    background-color: rgba(255, 255, 255, 0);
  }
  #settings{
    position: absolute;
    top: 0;
    right: 0;
    border-top: 1px solid darkslategrey;
    border-left: 1px solid darkslategrey;
    border-right: 2px solid darkslategrey;
    border-bottom: 2px solid darkslategrey;
    border-radius: 3px;
    text-align: center;
    padding: 2px 3px;
    font-size: 25px;
    line-height: 1em;
    font-weight: 500;
    background-color: rgba(211, 211, 211, 0.5);
  }
  #settings span{
    padding: 0;
    opacity: .8;
  }

  #taskInfo{
    background-color: white;
    border: 2px solid darkslategrey;
    border-radius: 5px;
    position: absolute;
    z-index: 1000;
    top: 20px;
    left: 45px;
    display: flex;
    flex-flow: column nowrap;
    align-items: center;
    padding: 10px 0;
    width: 90vw;
    max-width: 500px;
  }
/* Get computed width of .text and have this as taskInfo width! */

  .taskInfoInput{
    width: -webkit-fill-available!important;
    margin: 10px 20px;
    text-align: left;
  }

  #taskInfoBtn{
    margin: 10px 0;
  }
  .topList{
    margin-bottom: 0;
  }
  .sousBtn{
    margin-top: 0;
  }
  #listSection{
    text-align: left;
  }
  #toDoSection{
    display: flex;
    flex-flow: column nowrap;
    text-align: center;
  }
  #toDoSection button{
    width: fit-content;
    margin: 10px auto;
  }
  #taskToDo{
    font-size: 1.5em;
    font-weight: 700;
  }
  .moreInfoChevron{
    display: inline-block;
    transform: rotate(90deg);
    font-size: 25px;
    line-height: 25px;
  }
  #moreInfoDiv{
    opacity: 0;
    visibility: hidden;
    display: block;
    height: 0;
    flex-grow: 1;
  }
  #moreInfoInput:checked + label span{
    transform: rotate(-90deg);
  }
  #moreInfoInput:checked ~ #moreInfoDiv{
    opacity: 1;
    visibility: visible;
    min-height: fit-content;
    height: fit-content;
    width: fit-content;
    padding: 10px 15px;
    margin: auto;
    border-width: 1px 2px 3px;
    border-style: solid;
    border-color: darkslategrey;
    border-radius: 5px;
  }

  ul{
    list-style: none;
    padding: 0;
  }
  #list{
    margin-top: 0;
    width: 100%;
  }
  #list li{
    width: 100%;
    position: relative;
    font-weight: 600;
    display: flex;
    flex-flow: row nowrap;
    justify-content: space-between;
    align-items: baseline;
  }
  li span{
    padding-right: 3px;
    font-size: 1.3em;
  }
  li .text{
    flex-grow: 1;
  }
  .colorSpan{
    padding-left: 10px;
  }
  .emptyCheck{
    font-size: 2em;
    translate: 0 3.5px;
    line-height: 1em;
  }
  .trashCan, .recycle{
    padding-left: 10px;
    font-size: 1.5em;
  }
  
  #colorPalet{
    background-color: white;
    border: 2px solid darkslategrey;
    border-radius: 5px;
    position: absolute;
    z-index: 1000;
    top: 2px;
    right: 2.5px;
  }
  .colorTd{
    width: fit-content;
    height: 25px;
    border: none;
  }
  input[name="colorRadio"] + label > div{
    width: 70px;
    height: 25px;
    display: flex;
    justify-items: center;
    align-items: center;
    border-radius: 2.5px;
  }
  input[name="colorRadio"]:checked + label > div{
    background-color: rgba(47, 79, 79, .3);
 
  }
  .colorDiv{
    width: 65px;
    height: 20px;
    border-radius: 25px;
    border: none;
    margin: auto;
    line-height: 14px;
    text-align: center;
    font-size: 14px;
    padding: 3px 7px 4px;
  }
  .orange{
    background-color: orange;
  }
  .red{
    background-color: red;
  }
  .darkmagenta{
    background-color: darkmagenta;
    color: white;
  }
  .dodgerblue {
    background-color: dodgerblue;
  }
  .forestgreen{
    background-color: forestgreen;
    color: white;
  }
  .darkslategrey{
    background-color: darkslategrey;
    color: white;
  }

  hr{
    margin: 30px 0 0;
  }
  #doneZone{
    margin-top: 8px;
  }
  #doneZone li{
    display: flex;
    flex-flow: row nowrap;
    justify-content: space-between;
    align-items: baseline;
  }
  #doneZone li span.text{
    font-size: 18px;
    text-decoration: line-through;
  }
  #doneZone p span{
    display: inline-block;
    margin-bottom: 0;
    padding-left: 7px;
  }
  #doneZone p:not(span){
    margin-bottom: 0;
    text-decoration: underline;
  }
  .cossin{
    width: 0.1px;
    margin: -2px;
    border: 0;
  }
  .displayNone{
    display: none!important;
  }
</style>
  <div id="listSection">
    <div id="clickScreen" class="Screen displayNone"></div>
    <div id="logInScreen" class="Screen">
      <div id="logInDiv" class="DivScreen">
        <h3>First thing's first...</h3>
        <h2 >Who do you think you are?!</h2>
        <button id="logInBtn" class="ScreenBtn1">Log in</button>
        <button id="tryBtn" class="ScreenBtn2">Free Trial</button>
      </div>
    </div>
    <button id="settings"><span class="typcn typcn-cog-outline"></span></button>
    <div id="settingsScreen" class="Screen displayNone">
      <div id="settingsDiv" class="DivScreen">
        <span id="exitX">x</span>
        <button id="clearStorageBtn" style="margin-top: 15px;">Update</button>
        <hr />
        <h2>Settings</h2>
        <!-- <h3>Update</h3> -->
        <!-- <button id="clearStorageBtn"><span class="typcn typcn-cancel-outline" style="padding: 0;"></span></button> -->
        <h3>What time does your day really end?</h3>
        <input id="timeInput" type="time">
        <button id="settingsBtn" class="ScreenBtn1">yep <span class="typcn typcn-thumbs-up" style="padding: 0;"></span></button>
        <button id="cancelBtn" class="ScreenBtn2">Cancel</button>
      </div>
    </div>
    <form id="addForm">
      <input id="addInput" type="text" />
      <button id="addBtn" type="submit">add</button>
    </form>
    <h5 class="topList">The never ending list...</h5>
    <ul id="list"></ul>
    <div id="taskInfo" class="displayNone">
      <h5 class="topList taskInfoInput">Tell me more...</h5>
      <input type="text" id="taskTitle" class="taskInfoInput">
      <textarea id="taskDetails" class="taskInfoInput"></textarea>
      <button id="taskInfoBtn">Save Info</button>
    </div>
    <table id="colorPalet" class="displayNone">
      <tr class="colorTr">
        <td class="colorTd">
          <input type="radio" id="orangeRadio" name="colorRadio" value="orange" />
          <label for="orangeRadio">
            <div>
              <div class="colorDiv orange">people</div>
            </div>
          </label>
        </td>
        <td class="colorTd">
          <input type="radio" id="redRadio" name="colorRadio" value="red" />
          <label for="redRadio">
            <div>
              <div class="colorDiv red">urgent</div>
            </div>
          </label>
        </td>
      </tr>
      <tr class="colorTr">
        <td class="colorTd">
          <input type="radio" id="darkmagentaRadio" name="colorRadio" value="darkmagenta" />
          <label for="darkmagentaRadio">
            <div>
              <div class="colorDiv darkmagenta">errand</div>
            </div>
          </label>
        </td>
        <td class="colorTd">
          <input type="radio" id="dodgerblueRadio" name="colorRadio" value="dodgerblue" />
          <label for="dodgerblueRadio">
            <div>
              <div class="colorDiv dodgerblue">screen</div>
            </div>
          </label>
        </td>
      </tr>
      <tr class="colorTr">
        <td class="colorTd">
          <input type="radio" id="forestgreenRadio" name="colorRadio" value="forestgreen" />
          <label for="forestgreenRadio">
            <div>
                <div class="colorDiv forestgreen">physic</div>
            </div>
          </label>
        </td>
        <td class="colorTd">
          <input type="radio" id="darkslategreyRadio" name="colorRadio" value="darkslategrey" checked/>
          <label for="darkslategreyRadio">
            <div>
              <div class="colorDiv darkslategrey">else</div>
            </div>
          </label>
        </td>
      </tr>
    </table>
    <button id="shuffleBtn">Shuffle it!</button>
    <h5 class="sousBtn">Tell me what to do!</h5>
    <hr />
    <h3 style="display: inline-block;">Done Zone</h3>
    <button id="cloudIt"><span class="typcn typcn-cloud-storage-outline"></span></button>
    <ul id="doneZone"></ul>
  </div>
  <div id="toDoSection" class="displayNone">
    <h3>Fac là,<br />pour les 30 prochaines minutes,<br />tu vas...</h3>
    <p id="taskToDo"></p>
    <div id="moreInfoWhole" class="displayNone">
      <input id="moreInfoInput" type="checkbox" class="cossin" />
      <label for="moreInfoInput"><span class="typcn typcn-chevron-right-outline moreInfoChevron"></span></label>
      <div id="moreInfoDiv"></div>
    </div>
    <button id="nopeNextBtn"><span class="typcn typcn-arrow-sync"></span>Nope, next!<span class="typcn typcn-arrow-sync"></span></button>
    <button id="doneNextBtn"><span class="typcn typcn-thumbs-up"></span>Done, next!!<span class="typcn typcn-arrow-right-outline"></span></button>
    <button id="backBtn"><span class="typcn typcn-arrow-left-outline"></span>Back!</button>
  </div>
  <!-- errands, housework, computer, cellphone, people -->
  <!-- <table id="colorPalet" class="displayNone">
    <tr class="colorTr">
      <td class="colorTd">
        <input type="radio" id="orangeRadio" name="colorRadio" value="orange" />
        <label for="orangeRadio">
          <div>
            <div class="colorDiv orange"></div>
          </div>
        </label>
      </td>
      <td class="colorTd">
        <input type="radio" id="redRadio" name="colorRadio" value="red" />
        <label for="redRadio">
          <div>
            <div class="colorDiv red"></div>
          </div>
        </label>
      </td>
      <td class="colorTd">
        <input type="radio" id="darkmagentaRadio" name="colorRadio" value="darkmagenta" />
        <label for="darkmagentaRadio">
          <div>
            <div class="colorDiv darkmagenta"></div>
          </div>
        </label>
      </td>
    </tr>
    <tr class="colorTr">
      <td class="colorTd">
        <input type="radio" id="dodgerblueRadio" name="colorRadio" value="dodgerblue" />
        <label for="dodgerblueRadio">
          <div>
            <div class="colorDiv dodgerblue"></div>
          </div>
        </label>
      </td>
      <td class="colorTd">
        <input type="radio" id="forestgreenRadio" name="colorRadio" value="forestgreen" />
        <label for="forestgreenRadio">
          <div>
              <div class="colorDiv forestgreen"></div>
          </div>
        </label>
      </td>
      <td class="colorTd">
        <input type="radio" id="darkslategreyRadio" name="colorRadio" value="darkslategrey" checked/>
        <label for="darkslategreyRadio">
          <div>
            <div class="colorDiv darkslategrey"></div>
          </div>
        </label>
      </td>
    </tr>
  </table>-->
<script type="module">

// Add a setting: what time does your day really end?

  import { getFirestore, collection, getDocs, getDoc, query, where, addDoc, deleteDoc, doc, setDoc, updateDoc, deleteField, writeBatch, Timestamp } from "https://www.gstatic.com/firebasejs/9.10.0/firebase-firestore.js";
  import { getAuth, GoogleAuthProvider, signInWithRedirect, getRedirectResult, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.10.0/firebase-auth.js";
  import { app, analytics, db, auth, provider } from "../myFirebase.js";
  auth.languageCode = 'fr';

  getRedirectResult(auth)
    .then((result) => {
      // This gives you a Google Access Token. You can use it to access Google APIs.
      const credential = GoogleAuthProvider.credentialFromResult(result);
      const token = credential.accessToken;
      // The signed-in user info.
      const user = result.user;
      // IdP data available using getAdditionalUserInfo(result)
  }).catch((error) => {
      // Handle Errors here.
      const errorCode = error.code;
      const errorMessage = error.message;
      // The email of the user's account used.
      // const email = error.customData.email;
      // The AuthCredential type that was used.
      const credential = GoogleAuthProvider.credentialFromError(error);
  });

  function logIn(){
    signInWithRedirect(auth, provider);
  };
  let userConnected = false;
  onAuthStateChanged(auth,(user) => {
    if(user){
      userConnected = true;
      console.log(user);
      logInScreen.classList.add("displayNone");
      getCloudBC();
      getTasksSettings();
      getDones();
    } else{
      userConnected = false;
      logInScreen.classList.remove("displayNone");
      logInBtn.addEventListener("click", logIn);
      tryBtn.addEventListener("click", freeIn); //tryOne (for trying)
      cloudIt.classList.add("displayNone");
    };
  });

  
  
  
// *** START
  let listTasks = [];
  let listDones = [];
  let myListTasks = [];
  let myListDones = [];
  let myTomorrow = ``;
  let cBC;

  function getCloudBC(){
    if(localStorage.getItem("cBC")){
      cBC = localStorage.cBC;
      let cBCD = cBC >= 10 ? 1 : "." + cBC;
      cloudIt.style.backgroundColor = "rgba(237, 20, 61, " + cBCD + ")";
    } else {
      cBC = 0;
      localStorage.setItem("cBC", cBC);
    };
  };

  async function getTasksSettings() {
    const getTasks = await getDoc(doc(db, "randomTask", auth.currentUser.email));
    if(localStorage.getItem("myTomorrow")){
      myTomorrow = localStorage.myTomorrow;
    } else {
      myTomorrow = getTasks.data().myTomorrow; //not sure if that'll work since it's a string in firestore and backticks here...
    };
    
    if(localStorage.getItem("listTasks")){
      listTasks = JSON.parse(localStorage.listTasks);
    } else if(getTasks.exists()){
      getTasks.data().listTasks.map((todo) => {
        let taskIt = todo.task;
        let colorIt = todo.color;
        let infoIt = todo.info;
        myListTasks.push({task: taskIt, color: colorIt, info: infoIt});
      });
      listTasks = myListTasks;
      localStorage.listTasks = JSON.stringify(listTasks);
    };
    let idT = 0;
    listTasks.forEach(todo => {
      todoCreation(todo, idT);
      idT++;
    });
  };

  async function getDones(){
    const getDones = await getDocs(collection(db, "randomTask", auth.currentUser.email, "myListDones"));
    if(localStorage.getItem("listDones")){
      listDones = JSON.parse(localStorage.listDones);
    } else if(getDones){
      getDones.forEach((donedDate) => {
        let mydate = donedDate.id;
        let donedDateDones = donedDate.data().dones;
        let mylist = [];
        donedDateDones.map((done) => {
          let taskIt = done.task;
          let colorIt = done.color;
          let infoIt = done.info;
          mylist.push({task: taskIt, color: colorIt, info: infoIt});
        });
        myListDones.push({date: mydate, list: mylist});
      });
      listDones = myListDones;
      localStorageDones("first");
      console.log(listDones);
    };
    let sortedListDones = listDones.sort((d1, d2) => (d1.date > d2.date) ? 1 : (d1.date < d2.date) ? -1 : 0);
    sortedListDones.forEach(doned => {
      if (doned.list.length !== 0) {
        let donedDate = doned.date;
        donedDateCreation(donedDate);
        doned.list.forEach(tidoned => {
          donedCreation(donedDate, tidoned);
        });
      };
    });
    refreshDoneId();
  };

  function tryOne(){
    let sortedListDones = listDones.sort((d1, d2) => (d1.date > d2.date) ? 1 : (d1.date < d2.date) ? -1 : 0);
    sortedListDones.forEach(doned => {
      if(doned.list.length !== 0){
        let donedDate = doned.date;
        donedDateCreation(donedDate);
        doned.list.forEach(tidoned => {
          donedCreation(donedDate, tidoned);
        });
      };
    });
  refreshDoneId();
  logInScreen.classList.add("displayNone");
  };

  function freeIn(){ 
    if(localStorage.getItem("myTomorrow")){
      myTomorrow = localStorage.myTomorrow;
    };
    
    if(localStorage.getItem("listTasks")){
      listTasks = JSON.parse(localStorage.listTasks);
      let idT = 0;
      listTasks.forEach(todo => {
        todoCreation(todo, idT);
        idT++;
      });
    };
    
    if(localStorage.getItem("listDones")){
      listDones = JSON.parse(localStorage.listDones);
      let sortedListDones = listDones.sort((d1, d2) => (d1.date > d2.date) ? 1 : (d1.date < d2.date) ? -1 : 0);
      sortedListDones.forEach(doned => {
        if(doned.list.length !== 0){
          let donedDate = doned.date;
          donedDateCreation(donedDate);
          doned.list.forEach(tidoned => {
            donedCreation(donedDate, tidoned);
          });
        };
      });
      refreshDoneId();
    };
    
    logInScreen.classList.add("displayNone");
  };
  

// Tests
  // listDones = [
  //   { date: "2023-10-17",
  //     list: [{task: "manger", color: "red"}, {task: "toilet", color: "forestgreen"}]}, 
  //   { date: "2023-10-18",
  //     list: [{task: "ménage", color: "forestgreen"}, {task: "Time", color: "dodgerblue"}]}, 
  //   { date: "2023-10-16",
  //     list: [{task: "ménage", color: "forestgreen"}, {task: "Time", color: "dodgerblue"}]}, 
  //   { date: "2023-10-08",
  //     list: [{task: "ménage", color: "forestgreen"}, {task: "Time", color: "dodgerblue"}]}, 
  //   { date: "2023-10-15",
  //     list: [{task: "ménage", color: "forestgreen"}, {task: "Time", color: "dodgerblue"}]}
  // ];


  
  //push date in modif everytime you modify it, then empty it when the update has been done.

  function addModif(date){
    let modif = getModif();
    if(!modif.includes(date)){
      modif = [...modif, date];
      //localStorage.setItem("modif", JSON.stringify(modif));
      localStorage.modif = JSON.stringify(modif);
    };
  };

  function getModif(){
    let modif = [];
    if(localStorage.getItem("modif")){
      modif = JSON.parse(localStorage.modif);
    } else{
      modif = [];
    };
    return modif;
  };

  function resetModif(){
    localStorage.modif = JSON.stringify([]);
  };

  function addDeleted(date){
    let deleted = getDeleted();
    let modif = getModif();
    if(modif.includes(date)){
      let idx = modif.indexOf(date);
      modif.splice(idx, 1);
      //localStorage.setItem("modif", JSON.stringify(modif));
      localStorage.modif = JSON.stringify(modif);
    };
    if(!deleted.includes(date)){
      deleted = [...deleted, date];
      //localStorage.setItem("deleted", JSON.stringify(deleted));
      localStorage.deleted = JSON.stringify(deleted);
    };
  };

  function getDeleted(){
    let deleted = [];
    if(localStorage.getItem("deleted")){
      deleted = JSON.parse(localStorage.deleted);
    } else{
      deleted = [];
    };
    return deleted;
  };

  function resetDeleted(){
    localStorage.deleted = JSON.stringify([]);
  };


  

// *** CLOUDSAVE
  
  cloudIt.addEventListener("click", async () => {
    const batch = writeBatch(db);
    listTasks = JSON.parse(localStorage.listTasks);
    const docRefTasks = doc(db, "randomTask", auth.currentUser.email);
    const docSnapTasks = await getDoc(docRefTasks);
    if (docSnapTasks.exists()){
      batch.update(doc(db, "randomTask", auth.currentUser.email), { // or batch.update or await updateDoc
        listTasks: listTasks
      });
    } else{
      batch.set(doc(db, "randomTask", auth.currentUser.email), { // or batch.set or await setDoc
        listTasks: listTasks
      });
    }; 
    listDones = JSON.parse(localStorage.listDones);
    const docRefDones = collection(db, "randomTask", auth.currentUser.email, "myListDones");
    const docSnapDones = await getDocs(docRefDones);
    let modif = getModif();
    modif.map(modifDate => {
      let doned = listDones.find((td) => td.date == modifDate);
      if(docSnapDones[modifDate]){
        batch.update(doc(db, "randomTask", auth.currentUser.email, "myListDones", modifDate), {
          dones: doned.list
        });
      } else{
        batch.set(doc(db, "randomTask", auth.currentUser.email, "myListDones", modifDate), {
          dones: doned.list
        });
      };
    });
//Et si: on laisse les deleted dans la listDones (pas de splice), pourqu'ils puissent simplement se faire updater ici avec un array vide; et on fait juste ajouter un if que si lenght==0, on fait pas "donedDateCreation".
    // let deleted = getDeleted();
    // let empty = [{color: "", task: ""}];
    // deleted.map(deletedDate => {
    //   if(docSnapDones){
    //     if(docSnapDones[deletedDate]){
    //       batch.update(doc(db, "randomTask", auth.currentUser.email, "myListDones", deletedDate), {
    //         //dones: empty
    //         dones: deleteField()
    //         //["dones"]: deleteField()
    //         //dones: FieldValue.delete()
    //       });
    //       // batch.delete(doc(db, "randomTask", auth.currentUser.email, "myListDones", deletedDate)); //Not working!
    //     };
    //   };
    // });
     
    await batch.commit();
    resetCBC();
    resetModif();
    //resetDeleted();
  });

  async function cloudSaveTomorrow(){
    const docRef = doc(db, "randomTask", auth.currentUser.email);
    const docSnap = await getDoc(docRef);
    if (docSnap.exists()){
      await updateDoc(doc(db, "randomTask", auth.currentUser.email), {
        myTomorrow: myTomorrow
      });
    } else{
      await setDoc(doc(db, "randomTask", auth.currentUser.email), {
        myTomorrow: myTomorrow
      });
    };
  };

  function updateCBC(){
    console.log("cBC " + cBC);
    cBC++;
    localStorage.cBC = cBC;
    let cBCD = cBC >= 10 ? 1 : "." + cBC;
    console.log("cBCD " + cBCD);
    cloudIt.style.backgroundColor = "rgba(237, 20, 61, " + cBCD + ")";
  };
  function resetCBC(){
    cBC = 0;
    cloudIt.style.backgroundColor = "rgba(237, 20, 61, " + cBC + ")";
    localStorage.cBC = cBC;
  };

// *** SETTINGS
//How to know if you need to update it? (otherwise, it would still show "updated"; if not, shows "update"). Update because the version you have is older than the version on the cloud (because last time you saved on the cloud it was from an other localStorage/device... but it can't be because myList and list are different, because that doesn't tell you which one is the newer one... timestamps?)
//Is there a real way to check if it all really worked out before changing it to "updated!"?
  settings.addEventListener("click", () => {
    settingsScreen.classList.remove("displayNone");
    clearStorageBtn.addEventListener("click", () => {
      localStorage.clear();
      list.innerHTML = "";
      doneZone.innerHTML = "";
      listTasks = [];
      listDones = [];
      myListTasks = [];
      myListDones = [];
      resetCBC();
      getTasksSettings();
      getDones();
      clearStorageBtn.textContent = "Updated!";
    });
    exitX.addEventListener("click", () => {
      settingsScreen.classList.add("displayNone");
    });
    if(myTomorrow){
      timeInput.value = myTomorrow;
    };
    settingsBtn.addEventListener("click", () => {
      console.log(timeInput.value);
      myTomorrow = `${timeInput.value}`;
      localStorage.myTomorrow = myTomorrow;
      if(userConnected){
        cloudSaveTomorrow();
      };
      settingsScreen.classList.add("displayNone");
    });
    cancelBtn.addEventListener("click", () => {
      settingsScreen.classList.add("displayNone");
    });
  });

// *** CREATION
  function todoCreation(todo, idx){
    let li = document.createElement("li");
    li.innerHTML = `<span class="typcn typcn-media-stop-outline emptyCheck" onclick="checkEvent(this)"></span><span class="text" onclick="taskAddInfo(this)">${todo.task}</span><span class="typcn typcn-tag colorSpan" onclick="colorChoice(this)"></span>`;
    li.setAttribute("id", "todo" + idx);
    li.querySelector(".text").style.color = todo.color;
    list.appendChild(li);
  };

  function donedCreation(donedDate, doned){
    let donedLi = document.createElement("li");
    donedLi.innerHTML = `<span class="typcn typcn-tick"></span><span class="text">${doned.task}</span><span class="typcn typcn-trash trashCan" onclick="trashCanEvent(this)"></span><span class="typcn typcn-arrow-sync recycle" onclick="recycleEvent(this)"></span>`;
    donedLi.querySelector(".text").style.color = doned.color;
    document.getElementById(donedDate).appendChild(donedLi);
  };

  function donedDateCreation(donedDate){
    let today = getTodayDate();
    if(!document.getElementById(donedDate)){
      let donedUlP = document.createElement("p");
      donedUlP.setAttribute("id", donedDate + "p");
      donedUlP.innerText = donedDate;
      doneZone.insertAdjacentElement("afterbegin", donedUlP);
      let donedUl = document.createElement("ul");
      donedUl.setAttribute("id", donedDate);
      donedUlP.insertAdjacentElement("afterend", donedUl);
      if(donedDate == today){
        let todaySpan = document.createElement("span");
        todaySpan.innerText = "(aujourd'hui!)";
        donedUlP.insertAdjacentElement("beforeend", todaySpan);
      };
    };
  };

  function recycleEvent(recycle){
    let recycleLi = recycle.parentElement;
    let recycleId = recycleLi.id.slice(5);
    let recycleDate = recycleLi.parentElement.id;
    for (const i in listDones) {
      if (listDones[i].date == recycleDate) {
        let doned = listDones[i].list[recycleId];
        let todo = {
          task: doned.task,
          color: doned.color,
          info: doned.info
        };
        let idx = listTasks.length;
        listTasks.push(todo);
        localStorage.listTasks = JSON.stringify(listTasks);
        updateCBC();
        todoCreation(todo, idx);
      };
    };    
  };
  window.recycleEvent = recycleEvent;

// *** ADD
  addForm.addEventListener("submit", (e) => {
    e.preventDefault();
    let newTask = addInput.value;
    let color = "darkslategrey";
    if(!newTask == ""){
      let todo = {
        task: newTask,
        color: color
      };
      let idx = listTasks.length;
      listTasks.push(todo);
      localStorage.listTasks = JSON.stringify(listTasks);
      updateCBC();
      todoCreation(todo, idx);
      addForm.reset();
      console.log(listTasks);
    };
  });

// *** DONE/ERASE
  let num = 0;

  doneNextBtn.addEventListener("click", () => {
    let doneLi = document.querySelector("#todo" + num);
    console.log(doneLi);
    //let color = doneLi.querySelector(".text").style.color;
    doneLi.remove();
    refreshTodoId();
    gotItDone(num);
    if(listTasks.length == 0){
      taskToDo.innerText = "aller t'reposer!";
    } else{
      num = num < listTasks.length ? num : 0;
      taskToDo.innerText = listTasks[num].task;
      taskToDo.style.color = listTasks[num].color;
      if(listTasks[num].info){
        moreInfoWhole.classList.remove("displayNone");
        moreInfoDiv.innerText = listTasks[num].info;
      } else{
        moreInfoWhole.classList.add("displayNone");
      };
    };
  });

  function checkEvent(emptyCheck){
    console.log("checkEvent");
    console.log(listTasks);
    let li = emptyCheck.parentElement;
    //let color = li.querySelector(".text").style.color;
    //let task = li.querySelector(".text").textContent;
    let donedId = li.id.slice(4);
    li.remove();
    refreshTodoId();
    gotItDone(donedId);
  };
  window.checkEvent = checkEvent;
  
  function gotItDone(nb){
    console.log("gotItDone");
    console.log(nb);
    let donedTaskSplice = listTasks.splice(nb, 1);
    let donedTask = donedTaskSplice[0].task;
    console.log(donedTask);
    let donedColor = donedTaskSplice[0].color;
    console.log(donedColor);
    let donedInfo = donedTaskSplice[0].info;
    console.log(donedInfo);
    localStorage.listTasks = JSON.stringify(listTasks);
    let donedDate = getTodayDate(); //return
    let donedItem = {
      task: donedTask,
      color: donedColor,
      info: donedInfo
    };
    let dateFound = false;
    for (const i in listDones) {
      if (listDones[i].date == donedDate) {
        dateFound = true;
        listDones[i].list.push(donedItem);
      };
    };
    if(!dateFound){
      let doneList = [donedItem];
      let done = {
        date: donedDate,
        list: doneList
      };
      listDones.push(done);
    };
    
    addModif(donedDate);
    donedDateCreation(donedDate);
    donedCreation(donedDate, donedItem);
    refreshDoneId();
    localStorageDones("next");
  };

  function trashCanEvent(trashCan){
    let trashedLi = trashCan.parentElement;
    let trashedDate = trashedLi.parentElement.id;
    let trashedTaskId = trashedLi.id.slice(5);
    for (const i in listDones) {
      if (listDones[i].date == trashedDate) {
        listDones[i].list.splice(trashedTaskId, 1);
        addModif(trashedDate);
        if(listDones[i].list.length == 0){
          document.getElementById(trashedDate + "p").remove();
          document.getElementById(trashedDate).remove();
          //listDones.splice(i, 1); //Et si, on l'enlève pas de la liste? Il va pouvoir se faire updater comme les autres addModif, mais avec un array vide; On a juste à empêcher la recréation du donedDateCreation si length == 0
          //addDeleted(trashedDate); //That's not working at all
        };
      };
    };
    trashedLi.remove();
    refreshDoneId();
    localStorageDones("next");  
  };

  window.trashCanEvent = trashCanEvent;

  function localStorageDones(time){
    if(time == "next"){
      updateCBC();
    };
    let lastWeek = getLastWeekDate();
    console.log(lastWeek);
    let recent = listDones.filter((td) => td.date >= lastWeek);
    localStorage.listDones = JSON.stringify(recent);
  };


// *** REFRESH
  function refreshTodoId(){
    let idx = 0;
    document.querySelectorAll("#list li").forEach(li => {
      li.setAttribute("id", "todo" + idx);
      idx++;
    });
  };
  function refreshDoneId(){
    document.querySelectorAll("#doneZone ul").forEach(ul => {
      let idx = 0;
      ul.querySelectorAll("li").forEach(li => {
        li.setAttribute("id", "doned" + idx);
        idx++;
      });
    });
  };

// *** SHUFFLE
  shuffleBtn.addEventListener("click", () => {
    for (let i = listTasks.length - 1; i > 0; i--) { 
      const j = Math.floor(Math.random() * (i + 1)); 
      [listTasks[i], listTasks[j]] = [listTasks[j], listTasks[i]]; 
    };
    localStorage.listTasks = JSON.stringify(listTasks);
    list.innerHTML = ``;
    let idx = 0;
    listTasks.forEach(todo => {
      todoCreation(todo, idx);
      idx++;
    });
    listSection.classList.toggle("displayNone");
    toDoSection.classList.toggle("displayNone");
    num = 0;
    taskToDo.innerText = listTasks[num].task;
    taskToDo.style.color = listTasks[num].color;
    if(listTasks[num].info){
      moreInfoWhole.classList.remove("displayNone");
      moreInfoDiv.innerText = listTasks[num].info;
    } else{
      moreInfoWhole.classList.add("displayNone");
    };
  });

  nopeNextBtn.addEventListener("click", () => {
    console.log(listTasks.length + " " + num);
    if(listTasks.length == 0){
      taskToDo.innerText = "aller t'reposer!";
    } else{
      num = num < (listTasks.length - 1) ? num + 1 : 0;
      console.log(listTasks.length + " " + num);
      taskToDo.innerText = listTasks[num].task;
      taskToDo.style.color = listTasks[num].color;
      if(listTasks[num].info){
        moreInfoWhole.classList.remove("displayNone");
        moreInfoDiv.innerText = listTasks[num].info;
      } else{
        moreInfoWhole.classList.add("displayNone");
      };
    };
  });
    
  backBtn.addEventListener("click", () => {
    listSection.classList.toggle("displayNone");
    toDoSection.classList.toggle("displayNone");
  });
  
// *** DETAILS
let taskToInfo;
let taskToInfoId;
  function taskAddInfo(thisOne){
    taskToInfo = thisOne; //taskToInfo est le span.text qui a été cliqué
    let width = getComputedStyle(taskToInfo).width;
    taskInfo.style.width = width;
    taskToInfo.insertAdjacentElement("afterend", taskInfo); //taskInfo est le div qui apparait
    taskInfo.classList.remove("displayNone");
    clickScreen.classList.remove("displayNone");
    let taskTitleInfo = taskToInfo.textContent; //taskTitleInfo est le text contenu dans taskToInfo (span.text)
    taskTitle.value = taskTitleInfo; //taskTitle est le input qui doit contenir le titre, dans le div
    taskToInfoId = taskToInfo.parentElement.id.slice(4);
    taskTitle.style.color = listTasks[taskToInfoId].color;
    if(listTasks[taskToInfoId].info){
      taskDetails.value = listTasks[taskToInfoId].info; //taskDetails est le testarea qui doit contenir les détails (si y'en a déjà), dans le div
    } else{
      taskDetails.value = "";
    };
    
    document.querySelector("#clickScreen").addEventListener("click", () => clickHandlerAddOn(taskInfo));
  };
  window.taskAddInfo = taskAddInfo;
  window.listTasks = listTasks;

  taskInfoBtn.addEventListener("click", () => {
    listTasks[taskToInfoId].task = taskTitle.value;
    listTasks[taskToInfoId].info = taskDetails.value;
    console.log(listTasks);
    taskToInfo.textContent = taskTitle.value;
    localStorage.listTasks = JSON.stringify(listTasks);
    updateCBC();
    clickHandlerAddOn(taskInfo);
  });
// *** COLOR
//const colorList = ["orange", "red", "darkmagenta", "dodgerblue", "forestgreen", "darkslategrey"];
  let colorTag;
  function colorChoice(thisOne){
    colorTag = thisOne;
    colorTag.insertAdjacentElement("afterend", colorPalet);
    colorPalet.classList.remove("displayNone");
    clickScreen.classList.remove("displayNone");
    document.querySelectorAll("input[name='colorRadio']").forEach(radio => {
      radio.addEventListener("click", () => {
        let color = radio.value;
        let li = colorTag.parentElement;
        let liTask = li.querySelector(".text").textContent;
        li.querySelector(".text").style.color = color;
        console.log(liTask);
        let taskId = li.id.slice(4);
        listTasks[taskId].color = color;
        console.log(listTasks);
        localStorage.listTasks = JSON.stringify(listTasks);
        updateCBC();
        clickHandlerAddOn(colorPalet);
      });
    });
    document.querySelector("#clickScreen").addEventListener("click", () => clickHandlerAddOn(colorPalet));
  };
  window.colorChoice = colorChoice;

  function clickHandlerAddOn(addOn){
    addOn.classList.add("displayNone");
    list.insertAdjacentElement("afterend", addOn);
    clickScreen.classList.add("displayNone");
    document.querySelector("#clickScreen").removeEventListener("click", () => clickHandlerAddOn(addOn));
  };

// *** DATE
  function getTodayDate(){
    let date = new Date();
    let currentHour = String(date.getHours()).padStart(2, "0");
    let currentMinute = String(date.getMinutes()).padStart(2, "0");
    let currentTime = `${currentHour}:${currentMinute}`;
    let currentDay= String(date.getDate()).padStart(2, '0');
    currentDay = currentTime <= myTomorrow ? currentDay - 1 : currentDay;
    let currentMonth = String(date.getMonth()+1).padStart(2,"0");
    let currentYear = date.getFullYear();
    let currentDate = `${currentYear}-${currentMonth}-${currentDay}`;
    return currentDate;
  };

  function getLastWeekDate(){
    let date = new Date();
    date.setDate(date.getDate() - 7);
    let lastWeekDay= String(date.getDate()).padStart(2, '0');
    let lastWeekMonth = String(date.getMonth()+1).padStart(2,"0");
    let lastWeekYear = date.getFullYear();
    let lastWeekDate = `${lastWeekYear}-${lastWeekMonth}-${lastWeekDay}`;
    return lastWeekDate;
  };
  
</script>
</body>

</html>